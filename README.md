# Ход мыслей
В ходе выполнения задания, я задумался над тем какой алгоритм ограничения скорости работы выбрать
среди вариантов были алгоритмы по типу Leaky Bucket, Fixed Window, Sliding Log, Sliding Window, Token Bucket. \
Свой выбор я сделал в пользу Token Bucket т.к. его просто реализовать и он лишен многих проблем в сравнении
c "оконными вариантами" т.к. в их случае пользователь все равно мог бы превысить заданный лимит, но алгоритм
этого бы не отследил (например в случае когда большая часть запросов могла бы быть в промежутке между окнами)
Token Bucket было удобно реализовать для каждого пользователя, т.к. нужно хранить всего две переменные. \
В качестве хранилища данных был выбран Redis потому что в нем удобно хранить пары ключ-значение, а также он быстрый.
# Быстрый старт
Для быстрого старта нужно иметь установленный Docker и Docker-compose \
Чтобы его выполнить нужно перейти в корневую директорию проекта и выполнить команду: \
`make docker-compose-fc`\
Которая запустит два Docker контейнера redis-db и floodcontrol \

# Установка и запуск
Проект запускается в Docker контейнере с помощью docker-compose и сразу же проводит простое тестирование, для удобства Makefile содержит следующие зависимости:

`make help` - выводит подсказки по зависимостям \
`make docker-compose-fc` - запускает приложение в контейнере с помощью compose \
`make clean-redisdata` - очищает данные из базы данных \
`make docker-stop-fc` - останавливает работу контейнеров \
`make docker-clean-fc` - удаляет контейнеры \
`make fc-logs` - выводит логи с контейнера floodcontrol \
`make database-logs` - выводит логи с контейнера redis \
`make all-logs` - выводит все логи вместе

# Файл конфигурации
Проект содержит файл конфигурации под названием .env с полями:

`TOKENS` - Сколько запросов на заданное время (SECONDS) \
`SECONDS` -  Через сколько секунд обновляются токены (TOKENS) должно быть целым числом \
`SEND_RPS` -  Сколько запросов в секунду симулировать \
`USER_R` -  Сколько запросов от 1 юзера симулировать
